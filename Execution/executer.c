/**************************************************************************************************
*
* File Name: executer.c
*
* Author: Reed Terdal
*
* Created for CS344 on: 10/09/2019
*
* Purpose: Traverses the parse tree generated by the Parsing phase and executes statements sequentially.
 * This is what actually "runs" Jott code and will print out any results (including runtime-errors).
*
**************************************************************************************************/


#include "executer.h"
#include <math.h>
#include <stdio.h>
#include <Errors.h>

/**
 * @details This helps to keep track of "temporary" strings, such as printing out the result of a concat or charAt,
 * this are not assigned at any point and are thrown out after evaluation.
 * This lets us know that we can free this when we are done and not worry about double-frees
 */
typedef struct string_meta
{
    GString * data;
    bool is_intermediate;
}string_meta;


void execute(stmt_list *parse_tree) {
    for (stmt_list *current = parse_tree; current != NULL; current = current->statement_list)
    {
        if(current->statement != NULL)
        {
            if (current->statement->forNode != NULL) {
                run_for_loop(current->statement->forNode);
            } else if (current->statement->whileNode != NULL) {
                run_while_loop(current->statement->whileNode);
            } else if (current->statement->ifNode != NULL) {
                run_if_block(current->statement->ifNode);
            } else if (current->statement->re_asmt != NULL) {
                evaluate_re_assignment(current->statement->re_asmt);
            } else if (current->statement->expression != NULL)
            {
                void * retval = evaluate_expression(current->statement->expression);
                if(retval != NULL)
                {
                    if(current->statement->expression->string_expression != NULL && ((string_meta *)retval)->is_intermediate)
                    {
                        g_string_free(((string_meta *)retval)->data, TRUE);
                    }
                    free(retval);
                }
            }
            else if(current->statement->assignment != NULL)
            {
                evaluate_assignment(current->statement->assignment);
            }
            else if(current->statement->function_call != NULL)
            {
                void * retval = evaluate_function(current->statement->function_call);
                if(retval != NULL)
                {
                    if(current->statement->function_call->id->type == jf_str && ((string_meta *)retval)->is_intermediate)
                    {
                        g_string_free(((string_meta *)retval)->data, TRUE);
                    }
                    free(retval);
                }
            }
        }
    }
    destroyGlobalScope();
}

void *evaluate_assignment(asmt *asmt) {
    void *retval = evaluate_expression(asmt->expression);
    if (asmt->id->type == jstring) {
        setGlobalVariable(asmt->id->id, ((string_meta *) retval)->data);
        free(retval);
    } else {
        setGlobalVariable(asmt->id->id, retval);
    }
}

/**
 * @brief This is responsible for evaluating function calls
 * @param fCall The fCall that is going to be evaluated
 * @return This will return what ever the id type of the function is ie
 *          jf_int->     int64 *,
 *          jf_double -> double *,
 *          jf_string -> string_meta *,
 *          jf_void -> NULL
 */
void * evaluate_function(f_call * fCall)
{
    if(fCall != NULL)
    {
        if(fCall->id != NULL)
        {
            if(g_str_equal(fCall->id->id->str, "print"))
            {
                if(fCall->params != NULL && fCall->params->expression != NULL)
                {
                    if(fCall->params->expression->int_expression != NULL)
                    {
                        printf("%ld\n", evaluate_int_expression(fCall->params->expression->int_expression));
                    }
                    else if(fCall->params->expression->double_expression != NULL)
                    {
                        printf("%1.9g\n", evaluate_double_expression(fCall->params->expression->double_expression));
                    }
                    else if(fCall->params->expression->string_expression != NULL)
                    {
                        string_meta * result = evaluate_string_expression(fCall->params->expression->string_expression);
                        printf("%s\n", result->data->str);
                        if(result->is_intermediate)
                        {
                            g_string_free(result->data, TRUE);
                        }
                        free(result);
                    }
                }
            }
            else if(g_str_equal(fCall->id->id->str, "concat"))
            {
                if(fCall->params != NULL && fCall->params->expression != NULL &&
                fCall->params->expression->string_expression != NULL &&
                fCall->params->next != NULL && fCall->params->next->expression != NULL &&
                fCall->params->next->expression->string_expression != NULL)
                {
                    string_meta * first = evaluate_string_expression(fCall->params->expression->string_expression);
                    string_meta * second = evaluate_string_expression(fCall->params->next->expression->string_expression);
                    if(first->is_intermediate)
                    {
                        // If it is an intermediate (temporary), we can freely modify it
                        g_string_append(first->data, second->data->str);
                    }
                    else
                    {
                        // This is not an intermediate, meaning something else references it, so we can override with our new temporary
                        GString * new = g_string_new(first->data->str);
                        g_string_append(new, second->data->str);
                        first->data = new;
                    }
                    first->is_intermediate = TRUE; // This was created from other strings, it does not correspond to a permanent location (yet)
                    if(second->is_intermediate)
                    {
                        g_string_free(second->data, TRUE);
                    }
                    free(second);
                    return first;
                }
            }
            else if(g_str_equal(fCall->id->id->str, "charAt"))
            {
                if(fCall->params != NULL && fCall->params->expression != NULL &&
                   fCall->params->expression->string_expression != NULL &&
                   fCall->params->next != NULL && fCall->params->next->expression != NULL &&
                   fCall->params->next->expression->int_expression != NULL)
                {
                    gint64 index = evaluate_int_expression(fCall->params->next->expression->int_expression);
                    string_meta * str = evaluate_string_expression(fCall->params->expression->string_expression);
                    if(index < str->data->len)
                    {
                        GString * new = g_string_new(NULL);
                        g_string_append_c(new, str->data->str[index]);
                        string_meta * final = calloc(1, sizeof(string_meta));
                        final->data = new;
                        final->is_intermediate = TRUE;  // This was created from other strings, it does not correspond to a permanent location (yet)
                        if(str->is_intermediate)
                        {
                            g_string_free(str->data, TRUE);
                        }
                        free(str);
                        return final;
                    }
                }
            }
        }
    }
    return NULL;
}

/**
 * @brief Evaluates an int expression and returns the result
 * @param iExpr The int expression to evaluate
 * @return The result of the evaluation of the int expression
 */
gint64 evaluate_int_expression(i_expr * iExpr)
{
    if(iExpr != NULL)
    {
        if(iExpr->literal != NULL)
        {
            return iExpr->literal->value;
        }
        else if(iExpr->id != NULL)
        {
            runtime_variable * value = getGlobalVariable(iExpr->id->id);
            if(value != NULL && value->value != NULL)
            {
                return *((gint64 *)value->value);
            }
        }
        else if(iExpr->function_call != NULL)
        {
            gint64 * retVal = evaluate_function(iExpr->function_call);
            if(retVal != NULL)
            {
                return *retVal;
            }
        }
        else if(iExpr->LHS_expr != NULL && iExpr->operatorNode != NULL && iExpr->RHS_expr != NULL)
        {
            // Integer comparisons
            gint64 lhs = evaluate_int_expression(iExpr->LHS_expr);
            gint64 rhs = evaluate_int_expression(iExpr->RHS_expr);
            switch (iExpr->operatorNode->opType)
            {
                case op_add:  return lhs + rhs;
                case op_sub:  return lhs - rhs;
                case op_mult: return lhs * rhs;
                case op_pow:  return (gint64) pow(lhs, rhs);
                case op_div:
                    if(rhs != 0)
                    {
                        return lhs / rhs;
                    }
                    else
                    {
                        divide_by_zero_int_error(iExpr->LHS_expr, iExpr->RHS_expr);
                    }
                    break;
                case op_greater:
                    return lhs > rhs;
                case op_less:
                    return lhs < rhs;
                case op_goe:
                    return lhs >= rhs;
                case op_loe:
                    return lhs <= rhs;
                case op_neq:
                    return lhs != rhs;
                case op_eq:
                    return lhs == rhs;
            }
        } else if (iExpr->operatorNode != NULL) {

            // String comparisons
            if (iExpr->LHS_s_expr != NULL && iExpr->RHS_s_expr != NULL) {
                string_meta *lhs = evaluate_string_expression(iExpr->LHS_s_expr);
                string_meta *rhs = evaluate_string_expression(iExpr->RHS_s_expr);
                switch (iExpr->operatorNode->opType) {
                    case op_greater: {
                        int max = lhs->data->len;
                        if (lhs->data->len != rhs->data->len) {
                            return 0;
                        }
                        while (max > 0) {
                            if ((char) lhs->data->str[max] <= (char) rhs->data->str[max]) {
                                return 0;
                            }
                            max--;
                        }
                        return 1;
                    }
                    case op_less: {
                        int max = lhs->data->len;
                        if (lhs->data->len != rhs->data->len) {
                            return 0;
                        }
                        while (max > 0) {
                            if ((char) lhs->data->str[max] >= (char) rhs->data->str[max]) {
                                return 0;
                            }
                            max--;
                        }
                        return 1;
                    }
                    case op_goe: {
                        int max = lhs->data->len;
                        if (lhs->data->len != rhs->data->len) {
                            return 0;
                        }
                        while (max > 0) {
                            if ((char) lhs->data->str[max] < (char) rhs->data->str[max]) {
                                return 0;
                            }
                            max--;
                        }
                        return 1;
                    }
                    case op_loe: {
                        int max = lhs->data->len;
                        if (lhs->data->len != rhs->data->len) {
                            return 0;
                        }
                        while (max > 0) {
                            if ((char) lhs->data->str[max] > (char) rhs->data->str[max]) {
                                return 0;
                            }
                            max--;
                        }
                        return 1;
                    }
                    case op_neq: {
                        int max = lhs->data->len;
                        if (lhs->data->len != rhs->data->len) {
                            return 0;
                        }
                        while (max > 0) {
                            if ((char) lhs->data->str[max] == (char) rhs->data->str[max]) {
                                return 0;
                            }
                            max--;
                        }
                        return 1;
                    }
                    case op_eq: {
                        int max = lhs->data->len;
                        if (lhs->data->len != rhs->data->len) {
                            return 0;
                        }
                        while (max > 0) {
                            if ((char) lhs->data->str[max] != (char) rhs->data->str[max]) {
                                return 0;
                            }
                            max--;
                        }
                        return 1;
                    }
                }
            }
        }
        // Double comparisons
        if (iExpr->LHS_d_expr != NULL && iExpr->RHS_d_expr != NULL) {
            gdouble lhs = evaluate_double_expression(iExpr->LHS_d_expr);
            gdouble rhs = evaluate_double_expression(iExpr->RHS_d_expr);
            switch (iExpr->operatorNode->opType) {
                case op_greater:
                    return lhs > rhs;
                case op_less:
                    return lhs < rhs;
                case op_goe:
                    return lhs >= rhs;
                case op_loe:
                    return lhs <= rhs;
                case op_neq:
                    return lhs != rhs;
                case op_eq:
                    return lhs == rhs;
            }
        }
    }
    return 0;
}

/**
 * @brief Evaluates a string expression and returns the result
 * @param sExpr The string expression to evaluate
 * @return a string_meta which contains the string result and whether or not the string is a temporary
 */
string_meta * evaluate_string_expression(s_expr * sExpr)
{
    if(sExpr != NULL)
    {
        if(sExpr->literal != NULL)
        {
            string_meta * final = calloc(1, sizeof(string_meta));
            final->data = g_string_new(sExpr->literal->value->str);
            final->is_intermediate = TRUE;
            return final;
        }
        else if(sExpr->id != NULL)
        {
            runtime_variable * variable = getGlobalVariable(sExpr->id->id);
            if(variable != NULL && variable->value != NULL)
            {
                string_meta * final = calloc(1, sizeof(string_meta));
                final->data = (GString *)variable->value;
                final->is_intermediate = FALSE;
                return final;
            }
        }
        else if(sExpr->function_call != NULL)
        {
            return (string_meta *)evaluate_function(sExpr->function_call);
        }
    }
    return NULL;
}

/**
 * @brief Evaluates a double expression and returns the result
 * @param dExpr The double expression to evaluate
 * @return the result of the double expression evaluation
 */
gdouble evaluate_double_expression(d_expr * dExpr)
{
    if(dExpr != NULL)
    {
        if(dExpr->double_literal != NULL)
        {
            return dExpr->double_literal->value;
        }
        else if(dExpr->id != NULL)
        {
            runtime_variable * variable = getGlobalVariable(dExpr->id->id);
            if(variable != NULL && variable->value != NULL)
            {
                return *((gdouble *)variable->value);
            }
        }
        else if(dExpr->function_call != NULL)
        {
            gdouble * retval = evaluate_function(dExpr->function_call);
            if(retval != NULL)
            {
                return *retval;
            }
        }

        else if(dExpr->LHS_expr != NULL && dExpr->operator != NULL && dExpr->RHS_expr != NULL)
        {
            gdouble lhs = evaluate_double_expression(dExpr->LHS_expr);
            gdouble rhs = evaluate_double_expression(dExpr->RHS_expr);
            switch (dExpr->operator->opType)
            {
                case op_add:
                    return lhs + rhs;
                case op_sub:
                    return lhs - rhs;
                case op_mult:
                    return lhs - rhs;
                case op_div:
                    if(rhs != 0)
                    {
                        return lhs / rhs;
                    }
                    else
                    {
                        divide_by_zero_double_error(dExpr->LHS_expr, dExpr->RHS_expr);
                    }
                    break;
                case op_pow:
                    return (gdouble) pow(lhs, rhs);
                case op_greater:
                    return lhs > rhs;
                case op_less:
                    return lhs < rhs;
                case op_goe:
                    return lhs >= rhs;
                case op_loe:
                    return lhs <= rhs;
                case op_neq:
                    return lhs != rhs;
                case op_eq:
                    return lhs == rhs;
            }
        }
    }
}

/**
 * @brief Evaluates an expression and returns the result of the evaluation
 * @param expression The expression to evaluate
 * @return A pointer to the result of the evaluation, which depends on the type of expression,
 *      string_expression -> string_meta *
 *      int_expression -> int64 *
 *      double_expression -> double *
 */
void * evaluate_expression(expr * expression)
{
    void * retval = NULL;
    if(expression != NULL)
    {
        if(expression->string_expression != NULL)
        {
            retval = evaluate_string_expression(expression->string_expression);
        }
        else if(expression->int_expression != NULL)
        {
            retval = calloc(1, sizeof(gint64));
            *((gint64 *)retval) = evaluate_int_expression(expression->int_expression);
        } else if (expression->double_expression != NULL) {
            retval = calloc(1, sizeof(gdouble));
            *((gdouble *) retval) = evaluate_double_expression(expression->double_expression);
        }
    }
    return retval;
}

/**
 * Helper to recurse and call the correct functions in each b_stmt
 * @param stmts
 * @return
 */
void execute_b_stmt_list(b_stmt_list *stmts) {
    if (stmts == NULL) {
        return;
    }
    b_stmt *curr_stmt = stmts->b_statement;
    if (curr_stmt->expression != NULL) {
        evaluate_expression(curr_stmt->expression);
    } else if (curr_stmt->ifBlock != NULL) {
        run_if_block(curr_stmt->ifBlock);
    } else if (curr_stmt->whileLoop != NULL) {
        run_while_loop(curr_stmt->whileLoop);
    } else if (curr_stmt->forLoop != NULL) {
        run_for_loop(curr_stmt->forLoop);
    } else if (curr_stmt->reassign != NULL) {
        evaluate_re_assignment(curr_stmt->reassign);
    } else if (curr_stmt->functionCall != NULL) {
        evaluate_function(curr_stmt->functionCall);
    } else if (curr_stmt->whileLoop != NULL) {
        run_while_loop(curr_stmt->whileLoop);
    }
    execute_b_stmt_list(stmts->next);
}

/**
 * Run a for loop body a ceratin number of times
 * @param forNode
 * @return
 */
void run_for_loop(for_node *forNode) {
    evaluate_assignment(forNode->initialize);
    b_stmt_list *b_list = forNode->body;
    while (evaluate_int_expression(forNode->conditional) == 1) {
        evaluate_re_assignment(forNode->incrementer);
        execute_b_stmt_list(b_list);
    }

}

/**
 * Run a while loop for a certain number of iterations
 * @param whileNode
 * @return
 */
void run_while_loop(while_node *whileNode) {
    b_stmt_list *b_list = whileNode->body;
    while (evaluate_int_expression(whileNode->conditional) == 1) {
        execute_b_stmt_list(b_list);
    }

}

/**
 * Run an if statement
 * @param ifNode
 * @return
 */
void run_if_block(if_node *ifNode) {
    if (evaluate_int_expression(ifNode->expression) == 1) {
        execute_b_stmt_list(ifNode->b_true);
    } else {
        if (ifNode->b_false != NULL) {
            execute_b_stmt_list(ifNode->b_false);
        }
    }

}

/**
 * Evaluate a re-assigning node
 * @param r_asmt
 * @return
 */
void evaluate_re_assignment(r_asmt *r_asmt) {
    void *retval = evaluate_expression(r_asmt->expression);
    if (r_asmt->id->type == jstring) {
        setGlobalVariable(r_asmt->id->id, ((string_meta *) retval)->data);
        free(retval);
    } else {
        setGlobalVariable(r_asmt->id->id, retval);
    }
}